
## More Commands

nano <filename>                ->    Creats a file and enter the file to read or write to
wget <HTTP full link>          ->    This allows you to get files from the internet and download them in the terminal

scp                            ->    This allows you to copy files and directories form a current to remote or remote to current systems

ps                             ->    this command allows you to get a list of running process of our current user's session and info like 
                                     status code, the session that is running it, usage time of the CPU and name of program or command that is being executed.

ps aux                         ->    this commands allows you to see system process

top                            ->    this commands give you a real time update about the process on your system

kill <PID #>                   ->    kills the PID of that process under that id
SIGTERM                        ->    Kills the process, but allows it to do some cleanup tasks beforehand
SIGKILL                        ->    Kill the process - doesn't do any cleanup after the fact
SIGSTOp                        ->    Stop/suspend a process

                       * Our Machine to Remote Machine *
Example of scp :  scp important.txt ubuntu@192.168.1.30:/home/ubuntu/transferred.txt
What it means  :  command - file name on our machine - user on remote @ ip address - : where to store the file and what the file will be on the remote system.

                       * Remote System to Our Machine *
Example of scp :  scp ubuntu@192.168.1.30:/home/ubuntu/documents.txt notes.txt 
What it means  :  command - remote machine user @ ip address - where the file is and the name of it to copy - new name for our system to call it


## Serving files form your host - WEB

buntu machines come pre-packaged with python3. Python helpfully provides a lightweight and easy-to-use module called "HTTPServer". This module turns your computer 
into a quick and easy web server that you can use to serve your own files, where they can then be downloaded by another computing using commands such as curland wget. 

Python3's "HTTPServer" will serve the files in the directory that you run the command, but this can be changed by providing options that can be found in the manual pages. 
Simply, all we need to do is run python3 -m  http.server to start the module! In the screenshot below, we are serving from a directory called "webserver", which has a single named "file".

Now, let's use wgetto download the file using the computer's IP address and the name of the file. One flaw with this module is that you have no way of indexing, so you must know the exact name 
and location of the file that you wish to use. This is why I prefer to use Updog. What's Updog? A more advanced yet lightweight webserver. But for now, let's stick to using Python's "HTTP Server".

In the screenshot above, we can see that wget has successfully downloaded the file named "file" to our machine. .
This request is logged by SimpleHTTPServer much as any web server would, which I have captured in the screenshot below.


## How do Processes Start?

Let's start off by talking about namespaces. The Operating System (OS) uses namespaces to ultimately split up the resources available on the computer to (such as CPU, RAM and priority) processes. 
Think of it as splitting your computer up into slices -- similar to a cake. Processes within that slice will have access to a certain amount of computing power, however, 
it will be a small portion of what is actually available to every process overall.

Namespaces are great for security as it is a way of isolating processes from another -- only those that are in the same namespace will be able to see each other.

We previously talked about how PID works, and this is where it comes into play. The process with an ID of 0 is a process that is started when the system boots. 
This process is the system's init on Ubuntu, such as systemd, which is used to provide a way of managing a user's processes and sits in between the operating system and the user. 

For example, once a system boots and it initialises, systemd is one of the first processes that are started. 
Any program or piece of software that we want to start will start as what's known as a child process of systemd. 
This means that it is controlled by systemd, but will run as its own process (although sharing the resources from systemd) to make it easier for us to identify and the likes.

##  Getting Processes/Services to Start on Boot

Some applications can be started on the boot of the system that we own. For example, web servers, database servers or file transfer servers. 
This software is often critical and is often told to start during the boot-up of the system by administrators.

In this example, we're going to be telling the apache web server to be starting apache manually and then telling the system to launch apache2 on boot.

Enter the use of systemctl -- this command allows us to interact with the systemd process/daemon. Continuing on with our example, 
systemctl is an easy to use command that takes the following formatting: systemctl [option] [service]

For example, to tell apache to start up, we'll use systemctl start apache2. Seems simple enough, right? Same with if we wanted to stop apache, we'd just replace the [option] with stop 
(instead of start like we provided)

We can do four options with systemctl:
            Start
            Stop  
            Enable
            Disable


What command would we use to bring a previously backgrounded process back to the foreground?   -> fg
